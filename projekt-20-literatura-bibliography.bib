    @webpage{gnomeADG,
      author =       "Vincent Alexander and Calum Benson and Brian Cameron and Bill Haneman and Padraig O'Briain and Sharon Snider",
      title =        "GNOME Accessibility Developers Guide",
      howpublished = "online",
      publisher =    "GNOME Documentation Project",
      year =         "2008",
      url =          "https://developer.gnome.org/accessibility-devel-guide/stable/index.html.en",
      cited =        "2019-6-11"
    }

    @webpage{accessibleWidgets,
      author =       "Joanmarie Diggs",
      title =        "GTK+ and ATK - A Foundation for GNOME Accessibility",
      howpublished = "online",
      publisher =    "GNOME Documentation Project",
      year =         "2011",
      url =          "https://wiki.gnome.org/Accessibility/Documentation/GNOME2/AtkGuide/Gtk",
      cited =        "2019-6-11"
    }
    
    @webpage{yaml,
      author =       "Julia Di Russo",
      title =        "5 Reasons To Use YAML Files In Your Machine Learning Projects",
      howpublished = "online",
      publisher =    "towardsdatascience.com",
      year =         "2019",
      url =          "https://towardsdatascience.com/5-reasons-to-use-yaml-files-in-your-machine-learning-projects-d4c7b9650f27",
      cited =        "2020-4-21"
    }
    
    @webpage{pyatspi,
      author =       "Peter Parente",
      title =        "Package pyatspi",
      howpublished = "online",
      publisher =    "IBM Corporation",
      year =         "2007",
      url =          "https://people.gnome.org/~parente/pyatspi/doc/",
      cited =        "2019-12-8"
    }
    
    @webpage{accerciser,
      author =       "Eitan Isaacson and Peter Parente and Aline Bessa",
      title =        "Accerciser",
      howpublished = "online",
      publisher =    "GNOME Documentation Project",
      year =         "2014",
      url =          "https://help.gnome.org/users/accerciser/stable/index.html.en",
      cited =        "2019-12-17"
    }
    
    @webpage{pyatspi2,
      author =       "Steven Lee",
      title =        "Python Powered Accessibility",
      howpublished = "online",
      publisher =    "Python magazine",
      year =         "December 08",
      url =          "https://wiki.gnome.org/Accessibility/PythonPoweredAccessibility",
      cited =        "2019-12-8"
    }
    
    @webpage{dogtail_doc,
      author =       "Zack Cerza and Ed Rousseau and David Malcolm and Vita Humpa",
      title =        "Package dogtail",
      howpublished = "online",
      publisher =    "Red Hat, Inc.",
      year =         "2014",
      url =          "https://fedorapeople.org/~vhumpa/dogtail/epydoc/",
      cited =        "2019-12-20"
    }
    
    @webpage{opencv,
      author =       "{{OpenCV team}}",
      title =        "About Open Source Computer Vision Library",
      howpublished = "online",
      publisher =    "OpenCV",
      year =         "2019",
      url =          "https://opencv.org/about/",
      cited =        "2019-12-26"
    }
    
    @webpage{tesseract_history,
      author =       "Luc Vincent",
      title =        "Announcing Tesseract OCR",
      howpublished = "online",
      publisher =    "Google Developers Blog",
      year =         "2006",
      url =          "http://googlecode.blogspot.com/2006/08/announcing-tesseract-ocr.html",
      cited =        "2019-12-26"
    }
    
    @webpage{tesseract,
      author =       "Vaibhaw Singh Chandel",
      title =        "Deep Learning based Text Recognition (OCR) using Tesseract and OpenCV",
      howpublished = "online",
      publisher =    "Big Vision LLC",
      year =         "2018",
      url =          "https://www.learnopencv.com/deep-learning-based-text-recognition-ocr-using-tesseract-and-opencv/",
      cited =        "2019-12-26"
    }
    
    @webpage{xnee,
      author =       "{{Free Software Foundation, Inc}}",
      title =        "Introduction to GNU Xnee",
      howpublished = "online",
      year =         "2012",
      url =          "https://xnee.wordpress.com/",
      cited =        "2020-01-16"
    }
    
     @webpage{xpresser,
      author =       "Chris Gagnon",
      title =        "Xpresser",
      howpublished = "online",
      year =         "2012-12-22",
      url =          "https://wiki.ubuntu.com/Xpresser",
      cited =        "2020-01-16"
    }
    
    @webpage{gcov,
      author =       "Steve Best",
      title =        "Analyzing Code Coverage with gcov",
      howpublished = "online",
      year =         "2019-03-09",
      url =          "https://www.linuxtoday.com/blog/analyzing-code-coverage-with-gcov.html",
      cited =        "2020-01-16"
    }
    @webpage{bdd,
      author =       "Andrew Knight ",
      title =        "What is behavior-driven Python?",
      howpublished = "online",
      year =         "2018-05-28",
      url =          "https://opensource.com/article/18/5/behavior-driven-python",
      cited =        "2020-01-16"
    }
    
    @webpage{pythonframeworks,
      author =       "Arnab Roy Chowdhury",
      title =        "Top 5 Python Frameworks For Test Automation In 2019",
      howpublished = "online",
      year =         "2019-03-12",
      url =          "https://www.lambdatest.com/blog/top-5-python-frameworks-for-test-automation-in-2019",
      cited =        "2020-01-16"
    }
    
     @webpage{ci_tests,
      title =        "Automated Testing Advantages, Disadvantages and Guidelines",
      howpublished = "online",
      year =         "2005",
      url =          "http://www.exforsys.com/tutorials/testing/automated-testing-advantages-disadvantages-and-guidelines.html",
      cited =        "2020-04-25"
    }
    
    @webpage{flatpak,
      title =        "Flatpak",
      howpublished = "online",
      year =         "2020-03-16",
      url =          "https://wiki.debian.org/FlatPak",
      cited =        "2020-04-20"
     }
     
    @webpage{qecore,
        author =       "Michal Odehnal",
        title =        "Automation of Desktop Applications",
        howpublished = "online",
        year =         "2020",
        url =          "https://dogtail.gitlab.io/qecore/doc_basic_automation.html",
        cited =        "2020-04-20"
    }
     
    @webpage{exploratory_testing,
        author =       "DEEPAK PARMAR",
        title =        "Exploratory testing",
        howpublished = "online",
        url =          "https://www.atlassian.com/continuous-delivery/software-testing/exploratory-testing",
        cited =        "2020-04-20"
    }
      
    
    @article{guitesting,
    issn = {1382-3256},
    journal = {Empirical Software Engineering},
    pages = {694--744},
    volume = {20},
    publisher = {Springer US},
    number = {3},
    year = {2015},
    title = {Visual GUI testing in practice: challenges, problemsand limitations},
    language = {eng},
    address = {New York},
    author = {Alégroth, Emil, Feldt, Robert, Ryrholm, Lisa},
    keywords = {Visual GUI Testing ; Industrial case study ; Challenges ; Problems and Limitations ; System and acceptance test automation ; Development cost},
    }
    
    @ARTICLE{guidefinition,
    author={X. {Yuan} and M. B. {Cohen} and A. M. {Memon}},
    journal={IEEE Transactions on Software Engineering},
    title={GUI Interaction Testing: Incorporating Event Context},
    year={2011},
    volume={37},
    number={4},
    pages={559-574},
    ISSN={2326-3881},
    month={July},}
    
    @article{patternbasedtesting,
    issn = {0960-0833},
    journal = {Software Testing, Verification and Reliability},
    pages = {n/a--n/a},
    volume = {27},
    number = {3},
    year = {2017},
    title = {Pattern‐based GUI testing: Bridging the gap between design and quality assurance},
    author = {Moreira, Rodrigo M. L. M., Paiva, Ana Cristina, Nabuco, Miguel, Memon, Atif},
    keywords = {Gui Testing ;  Model‐Based Gui Testing ;  Pattern‐Based Gui Testing ;  Ui Test Patterns},
    }
    
    @article{nyman,
    journal = {Software Testing and Quality Engineering Magazine},
    title = {In Defense of Monkey Testing},
    pages = {18--21},
    year = {2000-01},
    author = {Noel Nyman},
    }
    
    @article{NguyenBao2014Gait,
    issn = {0928-8910},
    journal = {Automated Software Engineering},
    pages = {65--105},
    volume = {21},
    publisher = {Springer US},
    number = {1},
    year = {2014},
    title = {GUITAR: an innovative tool for automated testing of GUI-driven software},
    language = {eng},
    address = {Boston},
    author = {Nguyen, Bao, Robbins, Bryan, Banerjee, Ishan and Memon, Atif},
    keywords = {GUI testing ; Test automation ; Test generation},
    }
    
    @article{white_black,
    author = {Nidhra, S.},
    year = {2012},
    month = {06},
    pages = {29-50},
    title = {Black Box and White Box Testing Techniques - A Literature Review},
    volume = {2},
    journal = {International Journal of Embedded Systems and Applications},
    doi = {10.5121/ijesa.2012.2204}
    }
    
    @book{embedded,
    issn = {97814398},
    publisher = {CRC Press},
    isbn = {9781439818473},
    year = {2011},
    title = {Model-Based Testing for Embedded Systems},
    author = {Zander, Justyna and Schieferdecker, Ina and Mosterman, Pieter J.},
    language = {eng},
    keywords = {Computer Engineering ; Circuits & Devices ; Systems & Controls ; Engineering},
    }
    
    @inproceedings{TEMA,
    pages = {112--122},
    publisher = {IEEE},
    booktitle = {2009 31st International Conference on Software Engineering - Companion Volume},
    isbn = {9781424434954},
    year = {2009},
    title = {Automatic GUI test generation for smartphone applications - an evaluation},
    language = {eng},
    author = {Jaaskelainen, A and Katara, M and Kervinen, A and Maunumaa, M and Paakkonen, T and Takala, T and Virtanen, H},
    keywords = {Graphical User Interfaces ; Automatic Testing ; Software Testing ; System Testing ; Application Software ; Software Systems ; Libraries ; Cameras ; Optical Character Recognition Software ; Context Modeling},
    }
    
    @article{ci,
    author={Sacolick,Isaac},
    year={2018},
    month={May 10},
    title={What is CI/CD? Continuous integration and continuous delivery explained},
    journal={InfoWorld.com},
    note={Copyright - Copyright Infoworld Media Group May 10, 2018; Last updated - 2020-03-30},
    abstract={CI/CD defined Continuous integration is a coding philosophy and set of practices that drive development teams to implement small changes and check in code to version control repositories frequently.Because most modern applications require developing code in different platforms and tools, the team needs a mechanism to integrate and validate its changes.Continuous testing goes beyond test automation Automated testing frameworks help quality assurance engineers define, execute, and automate various types of tests that can help development teams know whether a software build passes or fails.A typical CD pipeline includes many of these steps: * Pulling code from version control and executing a build. * Executing any required infrastructure steps that are automated as code to stand up or tear down cloud infrastructure.. * Moving code to the target compute environment. * Managing the environment variables and configuring them for the target environment. * Pushing application components to their appropriate services, such as web servers, API services, and database services. * Executing any steps required to restarts services or call service endpoints that are needed for new code pushes. * Executing continuous tests and rollback environments if tests fail. * Providing log data and alerts on the state of the delivery.},
    keywords={Computers--Computer Industry; Software quality; Variables; Collaboration; Automation; Teams; Best practice; Packaging; Pipelines; Systems integration; Version control; Servers (computers); Quality assurance; Repositories; Infrastructure; Databases},
    language={English},
    }
    
    @article{ReisJacinto2018Aetw,
    issn = {0020-0190},
    abstract = {<p>Exploratory testing is a kind of software testing approach that emphasizes tester's experience to maximize the chances to find bugs within a specific time period. It is naturally a GUI-oriented testing activity for GUI-based systems. We propose aiding exploratory testing by providing a GUI model of the region impacted by the most recent internal code changes. We create such a delimited GUI model by pruning an original GUI model, quickly built by static analysis. This pruned GUI model is result of a reachability analysis between GUI elements and internal source code changes. Only related GUI elements are preserved. To illustrate the idea, we consider five GUI applications found in public repositories with varying changes among them. We present experimental data concerning two executions of two exploratory testing sessions: one without using our proposal and another with our proposal. For both testers, our proposal showed coverage gain in experimental data.</p> <p>•How...},
    journal = {Information Processing Letters},
    pages = {49--55},
    volume = {133},
    publisher = {Elsevier B.V},
    year = {2018},
    title = {Aiding exploratory testing with pruned GUI models},
    language = {eng},
    author = {Reis, Jacinto and Mota, Alexandre},
    keywords = {Software Engineering ; Gui Testing ; Static Analysis ; Exploratory Testing ; Change Request ; Software Engineering ; Gui Testing ; Static Analysis ; Exploratory Testing ; Change Request ; Computer Science},
    }


@inproceedings{ArltS2012LSAf,
    issn = {10719458},
    abstract = {<p>GUI testing is an active research area. The open challenge is the judicious generation of event sequences (an event sequence encodes a user interaction). A major advance in this direction is the use of a black-box model to systematically generate event sequences that are executable on the GUI. The black-box model can be, e.g., an Event Flow Graph (EFG) or an Event Sequence Graph (ESG). In this paper we propose a new approach to select relevant event sequences among the event sequences generated by a black-box model. We express the relevance of an event sequence by a precisely defined dependency between a fixed number of events in the event sequence. Departing from a pure black-box approach we apply a static analysis to the byte code of the application. This allows us to infer a dependency graph, which we call Event Dependency Graph (EDG). We use the EDG together with a black-box model to construct a set of relevant event sequences among the executable ones. We have implemented our approach in a new tool. We evaluate the approach on four open source GUI applications. With the specific choice of a lightweight static analysis, the approach scales to large applications and, at the same time, leads to an informed selection of event sequences. Using our approach we are able to find previously undetected bugs.</p>},
    pages = {301--310},
    publisher = {IEEE},
    booktitle = {2012 IEEE 23rd International Symposium on Software Reliability Engineering},
    isbn = {9781467346382},
    year = {2012},
    title = {Lightweight Static Analysis for GUI Testing},
    language = {eng},
    author = {Arlt, S and Podelski, A and Bertolini, C and Schaf, M and Banerjee, I and Memon, A. M},
    keywords = {Graphical User Interfaces ; Testing ; Java ; Transforms ; Educational Institutions ; Flow Graphs ; Computer Bugs ; Gui Testing ; Test Automation ; Black-Box Testing ; Static Analysis ; Computer Science},
    }
